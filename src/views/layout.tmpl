head
  meta(charset="UTF-8")
  meta(name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0")
  meta(content='text/html; charset=utf-8' http-equiv='Content-Type')
  meta(content='IE=edge, chrome=1' http-equiv='X-UA-Compatible')

  title Declaire.js

  link(href="/stylesheets/main.css" rel="stylesheet")
  link(href="/fontawesome/css/font-awesome.min.css" rel="stylesheet")
  link(href="/highlightjs/styles/github.css" rel="stylesheet")
  link(rel="shortcut icon" href="/favicon.png")

body
  header#header(data-title="1")
    .logo
      i.fa.fa-barcode
      span Declaire
    nav
      ul
        li
          a(href="#features") Features
        li
          a(href="#install") Get Started
        li
          a(href="/pages/docs") Documentation
        //- li
        //-   a(href="https://github.com/syntheticore/declaire") Github

  main
    header
      h1 Declaire.js
      h2 A minimal, yet complete Web Application Framework
      a.cta(href="#install") Get Started
      
    article#features
      ul.features
        li
          h3 Full Stack
          p
            | Declaire.js allows you to write a single web application that runs on both
            | client and server.
          p
            | Pages are first generated in a streaming fashion on the server
            | - for short time to first byte and easy SEO - and get rehydrated on the client
            | afterwards, using the same codebase.
          p
            | Declaire brings its own templating language, with a compact, 
            a(href="http://jade-lang.com" target="_blank") Jade
            | -inspired syntax and a robust set of logic blocks for structuring your markup.
          p
            | RESTfull resources get served for your models automatically, without the need to write
            | additional code. Just define a data model, create instances and you're good to go.
          p
            | Stylesheets written in
            a(href="http://learnboost.github.io/stylus/" target="_blank") Stylus 
            | /
            a(href="http://tj.github.io/nib/" target="_blank") Nib 
            | are compiled and served automatically for you.
        
        li
          h3 Declarative
          p
            | The template is the highest authority in a Declaire application and manages most
            | application state for you.
          p
            | ViewModels get instantiated and deleted by the template engine
            | as neccessary when data changes, freeing you from having to manage memory and event
            | handlers yourself.
          p
            | Writing application code in this declarative way minimizes overhead and prevents many
            | common programming mistakes.
        
        li
          h3 Auto Bindings
          p
            | Watch the DOM magically update, as your model data changes. No matter if those changes
            | resulted from your own actions or from updates to the database.
        
        li
          h3 Computed Properties
          p
            | Computed properties are like regular model methods, except that they also emit change
            | events when one of the properties they depend on changes. This allow you to hook up
            | complex logic to templates in a completely declarative way.
          p
            | Dependency tracking happens automatically, without the need to declare these
            | relationships ahead of time.
        
        li
          h3 Realtime Sync
          p
            | Model state is kept current with the remote database at all times automatically.
          p
            | Declaire does this in a scalable fashion, without the need for an additional PubSub
            | server like 
            a(href="http://redis.io" target="_blank") Redis
            | . A single 
            a(href="http://mongodb.org" target="_blank") MongoDB 
            | connection is sufficient for all data storage and synchronization needs.
        
        li
          h3 Offline First
          p
            | All Declaire applications work offline by default.
            | Data changes are kept in local browser storage when offline and get synced back to
            | the server later, when connectivity is available again.

        li
          h3 Streaming Server
          p
            | When templates get first rendered on the server, Declaire utilises 
            a(href="http://nodejs.org" target="_blank") Node.js
            | ' streaming technology to transmit the first few bytes as soon as possible. Browsers can
            | already display content and start downloading additional resources, while the database
            | is still returning data.
        
        li
          h3 Based on trusted Technology
          p
            | Declaire runs on 
            a(href="http://nodejs.org" target="_blank") Node.js 
            | and uses 
            a(href="http://expressjs.com" target="_blank") Express 
            | internally to serve requests.
            | Data is stored in a 
            a(href="http://mongodb.org" target="_blank") MongoDB 
            | instance, and code is packaged using 
            a(href="http://browserify.org" target="_blank") Browserify
            | .
          p
            | The express app, as well as the connected database instance are exposed to interested
            | applications just before listening for requests.
            | This allows you to hook up legacy code or load additional 
            a(href="http://expressjs.com/resources/middleware.html" target="_blank") express middleware 
            | and make changes to the database before serving requests.

        li
          h3 Scalable
          p
            | Declaire scales from simple websites and prototypes to complex web applications.
          p
            | Because of its full-stack, zero-config nature, applications are quickly
            | set up and running.
          p
            | Because of its declarative logic, flexible components and CommonJS module system, Declaire
            | also keeps more complex applications maintainable and fast.
          p 
            | Declaire also scales horizontally and runs on an arbitrary number of Node instances.
            | Both session and push management are realised in a scalable fashion.

        li
          //- h3 Decidedly Web
          h3 ❤ ing the Web
          p
            | In the transition from server generated pages to single-page applications, some values
            | of the web have - I believe - been lost in translation.
          //- p
          //-   | Pages often only contain a small fragment of
          //-   | container html and generate everything else using javascript. Some frameworks these days
          //-   | even go as far as bypassing the http protocol completely and transmit everything over websockets.
          //- p
          //-   | This is not only problematic for search engines and comparatively slow when it comes to
          //-   | time to first impression, but also undermines the movement to semantic html somewhat,
          //-   | by relying on a "semantic DOM" that only high-powered, javascript-savy browser engines
          //-   | can still consume, instead of, say, a simple shell script.
          p
            | Declaire therefore delivers:
          ul.list
            li Full HTML source for every page, instead of just a few script tags.
            li Data over standard REST/JSON.
            li Push updates using Server-Sent-Events over standard HTTP instead of websockets.

    nav#side-bar.side-bar
      header Contents
      ul
        li
          a(href="#install") Installation
        //- li
        //-   a(href="#get-started") Getting Started
        li
          a(href="#structure") Project Structure
          ul
            li
              a(href="#installing-modules") Installing Modules
        li
          a(href="#templating") Templating
          ul
            li
              a(href="#tags") Basic HTML Tags
            li
              a(href="#interpolation") Interpolation
            li
              a(href="#bindings") Two-way Bindings
            li
              a(href="#text") Text
            li
              a(href="#scope") Scope
            li
              a(href="#statements") Statements
              ul
                li
                  a(href="#statements-if") if
                li
                  a(href="#statements-for") for
                li
                  a(href="#statements-view") view
                li
                  a(href="#statements-action") action
                li
                  a(href="#statements-import") import
                li
                  a(href="#statements-content") content
                li
                  a(href="#statements-route") route
                li
                  a(href="#statements-switch") switch
            li
              a(href="#comments") Comments
        li
          a(href="#data-models") Data Models
          ul
            li
              a(href="#events") Events
            li
              a(href="#computed-properties") Computed Properties
            li
              a(href="#realtime") Realtime Updates
            li
              a(href="#relations") Relations
            li
              a(href="#model-offline") Local Storage
        li
          a(href="#view-models") View Models
        li
          a(href="#collections") Collections
          ul
            li
              a(href="#queries") Queries
        li
          a(href="#routing") Routing
        li
          a(href="#main-model") Main Model Instance
        //- li
        //-   a(href="#components") Imports and Components
        li
          a(href="#offline") Offline Support
        li
          a(href="#client-only") Client/Server-only Code
        li
          a(href="#stylesheets") Stylesheets
        li
          a(href="#deployment") Deployment
          ul
            li
              a(href="#mongodb") MongoDB
            li
              a(href="#heroku") Heroku

    section#main-content

      article#install
        h2 Install Declaire
        p
          | Install Declaire into any node application using 
          a(href="http://npmjs.com") npm
          | .
        pre(data-filename="Shell")
          code(class="javascript")
            | $ cd my-app
            | $ npm install declaire --save

      article#get-started
        h2 Get Started (with a nice and easy Todos app)
        p
          | To build a simple Todos app, create an application file, load declaire, define your models and
          | start the framework. This will make the application listen for requests on the server and for events
          | in the browser.
        pre(data-filename="app.js")
          code(class="javascript")
            | var declaire = require('declaire');
            |
            | var app = declaire.Application({
            |   mongoDevUrl: 'mongodb://127.0.0.1:27017/todos'
            | });
            |
            | var Todo = app.Model('todos', {
            |   title: 'Untitled Todo',
            |   done: false
            | });
            |
            | app.ViewModel('TodosView', {
            |   todos: Todo.all(),
            | 
            |   newTodo: function(input) {
            |     Todo.create({title: input.val()}).save();
            |     input.val('');
            |   },
            |
            |   rename: function(todo) {
            |     todo.setTemporary('renaming', true);
            |   },
            |
            |   finishRename: function(todo, e) {
            |     todo.save({name: e.element.val()});
            |     todo.setTemporary('renaming', false);
            |   }
            | });
            |
            | app.init(function(start) {
            |   start();
            | });
        p
          | Next, create your main layout template in the views folder.
          | Declaire will wrap it with an html tag automatically if you omit it.
        pre(data-filename="views/layout.tmpl")
          code(class="handlebars")
            | head
            |   title Todos
            |   link(href="/stylesheets/main.css" rel="stylesheet")
            | body
            |   {{view TodosView}}
            |     header
            |       h1 Todos
            |     main
            |       form({{action submit newTodo(input)}})
            |         input(type="text" placeholder="What's next?" {{as ::input}})
            |         button Create Todo
            |       ul.todos
            |         {{for todo in todos}}
            |           li>label
            |             input(type="checkbox" checked="{{bind! todo.done}}")
            |             h2({{action click rename(todo)}}) {todo.title}
            |             button({{action click todo.delete}}) Delete
            |             {{if todo.renaming}}
            |               input(type="text" placeholder="New Name" value="{:todo.name}" {{action enter finishRename(todo)}})
            |
            |     footer {todos.length} items left to do
        p
          | Finally, make sure you have a
          a(href="http://mongodb.org" target="_blank") MongoDB 
          | instance running on your local machine and run your
          | application with
          a(href="http://nodejs.org" target="_blank") Node 
          | like you always have. Enjoy!
        pre(data-filename="Shell")
          code(class="javascript")
            | $ node app.js

      article#structure
        h2 Structuring your Code
        p
          | Node.js uses the CommonJS standard for the definition and import of modules.
          | Your Declaire app will use it too, because it must be able to run on
          | the server as well. Declaire will package and serve your code using
          a(href="http://browserify.org" target="_blank") Browserify 
          | for usage in the browser.
        p To include another source file, just do as you're used to with node.
        pre(data-filename="app.js")
          code(class="javascript")
            | var myModule = require('./src/myModule.js');
        p 
          | Your directory structure should look like follows by default.
        pre(data-filename="fs")
          code(class="javascript")
            | /app
            |   .gitignore
            |   /public
            |     favicon.png
            |   /src
            |     /views
            |       layout.tmpl
            |   /stylesheets
            |     main.styl
            |   app.js
            |   package.json
        p The public folder should contain your static assets and will get served automatically.

        section#installing-modules
          h3 Installing and Loading Modules
          p
            | Install modules using NPM. These will get packaged and delivered with your app bundle
            | automatically. Require as usual.
          pre(data-filename="Shell")
            code(class="javascript")
              | $ npm install underscore --save
          pre(data-filename="app.js")
            code(class="javascript")
              | var _ = require('underscore');
          p
            | If you want to use a specific module only on the client or the server,
            | require the module inside a conditional. Server-only code will be optimized away from
            | the served app bundle automatically.
          pre(data-filename="app.js")
            code(class="javascript")
              | if(declaire.onServer()) {
              |   var NewRelic = require('newrelic');
              | }

      article#templating
        h2 Templating
        p
          | Declaire's templating language borrows syntax heavily from 
          a(href="http://jade-lang.com" target="_blank") Jade 
          | and
          a(href="http://handlebarsjs.com" target="_blank") Handlebars
          | , takes the streaming execution model from
          a(href="https://github.com/raptorjs/marko" target="_blank") Marko 
          | and hooks natively into declaire's models.
        p
          | Hierachy is denoted through indentation, interpolation uses curlies, statements use double
          | curlies and most other syntax adheres to HTML and CSS alot.
        p
          | Declaire uses a different evaluator on the client than on the server,
          | to process the exact same parse tree.
        p
          | The client evaluator operates directly on the DOM and creates, modifies and removes elements as neccessary
          | when data in your models changes.
        p
          | The server evaluator generates ordinary html source from the same parse tree and data. It
          | does so in a fashion that minimizes time to first byte, by streaming rendered chunks of markup
          | to the client already, while it's still waiting for the database to return  further data.
          | The asynchronous resolution of data in the view models is also taken into account and
          | the generated html is reassembled and streamed in the correct order.
        
        section#tags
          h3 Basic HTML Tags
          p
            | Use the <b>#</b> character to give elements an id, apply classes using <b>.</b> and
            | set attributes in parentheses using the regular html notation. Text may follow on the
            | same line, or other tags may be indented below.
            br
            | When an id or class is used, divs may have the tag name omited, as divs are the default.
          pre(data-filename="views/layout.tmpl")
            code(class="javascript")
              | // Simple div with a class and some text
              | div.box Hello
              |
              | // The same
              | .box Hello
              |
              | // Nest tags through indentation
              | nav
              |   ul.items
              |     li
              |       a(href="#") Item1
              |
              | // Make this a little shorter for elements with a single child
              | nav>ul.items
              |   li>a(href="#") Item1
              |
              | // Input with an id and several classes and attributes
              | input#my-id.foo.bar(type="checkbox" checked)

        section#interpolation
          h3 Interpolation
          p
            | Any value available in the surrounding scope can be interpolated at any practical point
            | in a template using a pair of curlies. When the value later changes, the DOM will update
            | accordingly. This also works for attributes.
            br
            | When a path returns null or undefined, the engine will silently render nothing.
          pre(data-filename="views/layout.tmpl")
            code(class="handlebars")
              | h2 {title}
              | input(type="checkbox" checked="{done}")
          p
            | By default, text gets escaped before being inserted into the page, to prevent injection attacks.
            | If you precede the curlies with an exclamation mark though, you can insert unescaped text.
            | Use this at your own risk!
          pre(data-filename="views/layout.tmpl")
            code(class="handlebars")
              | h2 !{title}
        
        section#bindings
          h3 Two-way Bindings
          p
            | Using double curlies in an attribute will create a two-way binding, meaning that the
            | input will also drive the connected model property when the user makes changes.
          pre(data-filename="views/layout.tmpl")
            code(class="handlebars")
              | input(type="checkbox" checked="{{done}}")
        
        section#text
          h3 Text
          p
            | When your text doesn't fit on a single line anymore, you can end a tag definition with a dot
            | and indent the following lines below. Text may also contain regular html tags.
          pre(data-filename="views/layout.tmpl")
            code(class="handlebars")
              | p.
              |   Lorem ipsum dolor sit amet
              |   Lorem ipsum &lt;b&gt;dolor&lt;/b&gt; sit amet
          p
            | Alternatively, you may insert text anywhere you would insert a regular tag, by preceding it
            | with the '|' character. This allows you to still insert intermediate tags using the regular
            | syntax. 
          pre(data-filename="views/layout.tmpl")
            code(class="handlebars")
              | p
              |   | Lorem ipsum
              |   a(href="#") dolor 
              |   | sit amet

        section#scope
          h3 Scope
          p
            | The scope controls what data is visible at any given point in a template.
          p
            | When you use a path in a template, that path is looked up in the scope. Imagine the scope
            | as a stack of objects, some of them models, some of them regular objects that contain variable
            | names, pointing to models.
            | Declaire searches for the first path segment upward in the stack, until it finds a variable
            | or model property that matches and retrieves it using <b>get</b>.
          p
            | All subsequent path segment are now basically syntax sugar for calling <b>get</b> again on the previous
            | object until we hit a base type that can be interpolated into the page.
          p
            | The scope at least contains the 
            a(href="#main-model") main model
            | , which Declaire inserts automatically.
            | New variable names and models get introduced to the scope by control statements like
            a(href="#statements-for") for 
            | and 
            a(href="#statements-view") view
            | .

        section#statements
          h3 Statements
          p
            | Several statements are available in templates to control the generated markup in response
            | to changes to its underlying data, accessible through their respective keywords in double curlies.
          section#statements-if
            h4 if
            p
              | The if statement is different from Javascript, in that it does not execute arbitrary code.
              | Only paths to model properties within the scope, as well as basic literals
              | are allowed, together with a fixed set of comparison operators. Inversion works too.
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{if person.name == 'Peter'}}
                |   strong That's him!
                |
                | {{if person.age < 18}}
                |   .rules Stay out!
                |
                | {{if !_online}}
                |   dialog Waiting for connection ...
            p
              | One or several alternatives can be declared as well.
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{if path}}
                |   | path is truthy
                | {{=>}}
                |   | path is falsy
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{if}}
                | {{=> value > 0}}
                |   .green Positive
                | {{=> value == 0}}
                |   div Zero
                | {{=>}} // Default
                |   .red Negative
          section#statements-for
            h4 for
            p
              | Use the for-statement to iterate through collections and produce output for
              | every item. When items get added to or removed from the collection later, the template
              | engine will only touch the affected parts of the DOM and leave other elements intact.
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | ul
                |   {{for todo in todos}}
                |     li {todo.title}
            p
              | You can also use the short form, which will insert each item directly into the scope,
              | making its properties visible from that point downward in the template.
              | Note that its properties may shadow properties or variables of the same name, higher in
              | the scope. These can then no longer be reached.
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | ul
                |   {{for todos}}
                |     li {title}
          section#statements-view
            h4 view
            p
              | The view statement instantiates a view model and puts it into the scope. Properties and methods
              | of the view model instance are subsequently visible in the scope.
            p
              | Once a view is no longer needed, perhaps because its item was removed from a collection,
              | or because a parent element got updated, Declaire will remove the associated view model object
              | automatically, causing it to fire its <a href="#view-models">remove</a> event.
            p
              | Optionally, the created view model instance can be given a name by which it will be accessible
              | in the scope. If you leave that out, the model itself will be inserted into the scope.
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{if showViews}}
                |   {{view MyViewModel as myView}}
                |     h1 {myView.title}
                |   {{view MyViewModel}}
                |     h1 {title}
            p
              | If you need to fetch data from the database to render the view, it is good practice to supply
              | an alternate piece of markup to render, should the application be offline and not find
              | the neccessary data in local storage.
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{view MyViewModel}}
                |   h1 {myView.author.name}
                | {{=>}}
                |   h1 You are not connected to the internet
                |   h2 This view will render automatically once connectivity returns
            p
              | Any value accessible from the scope can be passed as an argument to the view model constructor.
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{for todo in todos}}
                |   {{view TodoView(todo)}}
                |     h1 {description}
            pre(data-filename="app.js")
              code(class="javascript")
                | declaire.ViewModel('TodoView', {
                |   myTodo: null,
                |   description: function() {
                |     var todo = this.get('myTodo');
                |     return todo && todo.get('title').toUpperCase();
                |   }
                | }, function(todo) {
                |   this.set('myTodo', todo);
                | });

          section#statements-action
            h4 action
            p
              | When the user generates events by interacting with the page, your application can react
              | using the action statement. It takes the name of an event on the element and a method to
              | look up in the scope as arguments.
            p The method will get passed the originating DOM element as a parameter.
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{view MyView}}
                |   input(type="text" {{action keyup method}})
            pre(data-filename="app.js")
              code(class="javascript")
                | declaire.ViewModel('MyView', {
                |   method: function(input) {
                |     console.log(input.val());
                |   }
                | });

          section#statements-import
            h4 import
            p
              | Declair uses a simple way to combine templates that also serves as a basis to build
              | reusable components:
              | Use the import statement to import another template in the surrounding template.
            pre(data-filename="views/myTemplate.tmpl")
              code(class="handlebars")
                | h1 Import me!
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{import myTemplate}}
            p
              | Parameters passed to the imported template are delegated to the topmost view inside.
              | Inside the view, the passed object is then available under a different name, just
              | like with functions in a programming language. 
            p
              | Templates always get a clean scope that contains only the main model and the parameters
              | passed. They don't inherit the calling scope.
            pre(data-filename="views/MyView.tmpl")
              code(class="handlebars")
                | {{view MyView(word)}}
                |   h1 {word}
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{import MyView('foo')}}
                | {{import MyView('bar')}}
            p
              | This even works without a view model. In this case, the view statement simply works
              | as a way to pass parameters to a reusable, dynamic template. 
            pre(data-filename="views/animal.tmpl")
              code(class="handlebars")
                | {{view (name, species)}}
                |   .creature
                |     .name {name}
                |     .species {species}
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{import animal('Lisa', 'Dog')}}
                | {{import animal('Herbert', 'Cat')}}

          section#statements-content
            h4 content
            p
              | You can nest additional markup under an import statement. This can then be placed
              | inside the imported template using the <b>content</b> statement. 
            p 
              | This allows you to write components like dialogs, that act as wrappers around arbitrary
              | content.
            pre(data-filename="views/wrapper.tmpl")
              code(class="handlebars")
                | header
                |   h1 Own content
                | article
                |   {{content}}
                | footer
                |   .completely wrapped
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{import wrapper}}
                |   h2 Inserted content
                | {{import wrapper}}
                |   #other Inserted content

          section#statements-route
            h4 route
            p
              | Use the route statement to evaluate markup only for specific URLs. The given URL can contain wildcards,
              | which are used to extract parts of the url and put them into the scope below the statement.
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{route /pages/users/:user}}
                |   h1 Showing information for {user}
                |   {{view UserView(user)}}
                |     h2 Hello {firstName}

          section#statements-switch
            h4 switch
            p
              | When you nest markup below a regular if statement, the corresponding views and elements will be
              | removed from the DOM, when the statement's expression turns falsy and get created anew when it 
              | becomes true again.
            p
              | In some cases, you may wish your views to retain their state though, such as when cycling through
              | individual tabs in a tabbed container for instance. Use the switch statement to declare a number
              | of alternative states that are all kept in memory, while only a single element gets attached to
              | the DOM at any given point in time.
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{switch probability > 0.8}}
                |   {{view BadgeView}}
            pre(data-filename="views/layout.tmpl")
              code(class="handlebars")
                | {{switch}}
                | {{=> probability > 0.8}}
                |   {{view GreenView}}
                | {{=> probability > 0.5}}
                |   {{view OrangeView}}
                | {{=>}} // Default
                |   {{view RedView}}

        section#comments
          h3 Comments
          p
            | Comments begin with <b>//</b> and extend to the end of the line.
            | Comments always get their own line.
          pre(data-filename="views/layout.tmpl")
            code(class="javascript")
              | // This will not end up in your generated markup

      article#data-models
        h2 Data Models
        p
          | Data models structure your application data and code, shield you from the database, provide offline
          | capabilities and report updates to their data to interrested listeners using events.
        p
          | A model definition consists of a collection name, defaults for all attributes and methods
          | to operate on that data. In this example, JSON data for your todos will be available under the URL /api/todos.
        p
          | Note that model properties get accessed using the <b>get</b> and <b>set</b> methods and never directly.
        pre(data-filename="app.js")
          code(class="javascript")
            | var Todo = declaire.Model('todos', {
            |   title: 'Untitled Todo',
            |   done: false,
            |
            |   check: function() {
            |     this.set('done', true);
            |   }
            | });
        p
          | Individual models can now be created from that definition using the create method.
          | You can also pass a hash of values to the constructor to set some properties directly on creation.
          br
          | Once created, the object is visible to your application and fully functional, but is not
          | persisted to the server yet. To make it visible to other users of the app as well,
          | we need to save it to the database using the appropriately named method.
        pre(data-filename="app.js")
          code(class="javascript")
            | var todo = Todo.create({title: 'Foo'});
            | todo.check();
            | todo.save();
        p As a convenience, setting properties and saving immediately can be done in a single method call.
        pre(data-filename="app.js")
          code(class="javascript")
            | todo.save({done: true});
        
        section#events
          h3 Events
          p
            | In many cases, the event system is invisible to you and is used by the template engine
            | automatically to update the DOM when data in your models changes.
            | You can also access it yourself however, using a handful of methods:
          pre(data-filename="app.js")
            code(class="javascript")
              | // Change events for individual properties trigger first
              | todo.on('change:title', function(title) {
              |   console.log("The title changed to " + title);
              | });
              |
              | // Updates to one or many properties finalize with a generic
              | // change event, that carries a hash of all new values
              | todo.on('change', function(changes) {
              |   console.log("To resume...");
              |   for(var key in changes) {
              |     console.log(key + ' changed to ' + changes[key]);
              |   }
              | });
              |
              | // Destroy after use
              | todo.once('change:done', function() {
              |   console.log("This will get called only once");
              | });
              |
              | // Called when new data arrived from the network,
              | // on initial load or due to push updates
              | todo.on('fetch', function(changes) {
              |   console.log("This will fire last");
              | });
          p The <b>on</b> method returns the handler itself, so that it can be unregistered again later:
          pre(data-filename="app.js")
            code(class="javascript")
              | var handler = todo.on('change', function() {});
              | todo.off(handler);
          //- p What events are emited?
        
        section#computed-properties
          h3 Computed Properties
          p
            | Regular model methods implicitly become computed properties simply by accessing them
            | from a template or through the <b>get</b> method directly.
          p
            | They will then trigger change events, just like normal properties, when one of their
            | dependencies changes. These dependencies are tracked automatically upon the first
            | call to <b>get</b> and will subsequently get updated on every access.
          pre(data-filename="app.js")
            code(class="javascript")
              | var Person = declaire.Model('people', {
              |   firstName: '',
              |   lastName: '',
              |
              |   name: function() {
              |     return this.get('firstName') + ' ' + this.get('lastName');
              |   }
              | });
          pre(data-filename="views/ContactView.tmpl")
            code(class="handlebars")
              | h1 {name}

        section#realtime
          h3 Realtime Updates
          p
            | When model objects that you have checked out in your application change in the database, they
            | will automatically receive push updates from the server. This happens in such a way that local,
            | unsaved changes are preserved and take precedence over the remote changes.
          p
            | If you want to purge your local changes and revert back to the most recent database state,
            | simply call the <b>revert</b> method.
          pre(data-filename="app.js")
            code(class="javascript")
              | todo.set({done: true});
              | todo.get('done'); // true
              | todo.revert();
              | todo.get('done'); // false
          p
            | In addition to emiting the regular change events for every property that got changed and the
            | generic change event, the model will also fire a fetch event, that carries a hash of actual
            | changes. Note that the fetch event will also be fired when its list of changes is empty.
          pre(data-filename="app.js")
            code(class="javascript")
              | // Called when new data arrived from the network,
              | // on initial load or due to push updates
              | todo.on('fetch', function(changes) {});

        section#relations
          h3 Relations
          p
            | When you set a property of a model object to another model object, saving the first one will
            | automatically generate a reference to the second and save that to the database in its place.
            | The same goes for collections, which get serialized to a series of references before being
            | persisted.
          p
            | When the object is loaded again, its relations will get resolved automatically, but only one level deep.
            | This means that any directly referenced model objects will get loaded as well. Collections remain lazy.
          p
            | To use further references in the referenced model objects, these must then be resolved first.
            | Use the <b>resolve</b> method to do that.
          pre(data-filename="app.js")
            code(class="javascript")
              | Todo.load(todoId, function(todo) {
              |   var author = todo.get('author');
              |   // Regular properties are immediately available
              |   console.log(author.get('name'));
              |   // To use object references, author must be resolved first
              |   author.resolve(function() {
              |     console.log(author.get('father').get('name'));
              |   });
              | });

        section#model-offline
          h3 Local Storage
          p
            | 

      article#view-models
        h2 View Models
        p
          | View models inherit from declaire.Model, but fulfill a different purpose.
          br
          | They are the building blocks of your UI logic, cannot be saved and export a name by which they can
          | be instantiated from within templates using the <b>view</b> statement.
        p
          | Normally, a view model will want to fetch data on instantiation to make it available to templates.
          | Note that, as opposed to normal models, you cannot instantiate and delete these
          | yourself, as this job is done by the template engine automatically.
        p
          | Therefore, view models take a constructor function as their third argument, that gets passed the
          | fresh model instance as a parameter. If you manually allocate any resources or connect any event handlers
          | here, make sure that you also register for the <b>remove</b> event, to clean that up at the appropriate time.
        pre(data-filename="app.js")
          code(class="javascript")
            | declaire.ViewModel('Clock', {
            |   time: null
            | }, function() {
            |   // Update model state every second once the view exists
            |   var iv = setInterval(function() {
            |     this.set('time', new Date());
            |   }, 1000);
            |   // Clear handler when the view gets removed from the DOM
            |   this.on('remove', function() {
            |     clearInterval(iv);
            |   });
            | });
        pre(data-filename="views/layout.tmpl")
          code(class="handlebars")
            | {{view Clock}}
            |   time {time}
        p
          | See the
          a(href="#statements-view") view statement 
          | for detailed information on how to use view models inside templates.

      article#collections
        h2 Collections
        p
          | Collections represent a set of model objects at a potential REST endpoint.
          br
          | Use them to define the relationships between your models.
        p
          | When a model contains a collection as
          | a property, saving the model will only save references to other objects in its collection.
          | When the model is later loaded again, its collections will be restored.
          br
          | This happens immediately upon load for collection objects that are already in local storage.
          | Collections will not be resolved over the network automatically however, as this could
          | potentially trigger a chain reaction that would eventually load the entire database.
        p
          | You can force a collection to resolve by requesting its <b>values</b>, either through the method
          | of that name, implicitly by using its <b>each</b> method, or by calling the .
        pre(data-filename="app.js")
          code(class="javascript")
            | var c = declaire.Collection([1, 2, 3]);
            | c.push(4);
            | c.serialize() // [1,2,3,4]
            | var todos = declaire.Collection([);
            | c.push(Todo.create({done: true}));
            | c.serialize(); // error: cannot serialize unsaved objects
            | c.serialize({saveItems: true}, function(output) {}); // [{_ref: {id: 'xyz123', collection: 'todos'}}]
            | c.push(Todo.create({done: false}));
            | c.each(function(todo) {});
            | var values = c.values();
            | for(var i in values) {}
        p
          | They can also be used to hold data inside view models, even though these cannot be saved.
          // Make all collections lazy
          // col.filter() returns a query
          // Model.all returns a query
          // col.filter().filter() builds up lazy query
          // query.first() -> findOne
          // col.serialize -> array with base types or references
          // model references are first fetched on a call to get

          // Warnings like here https://youtu.be/z5e7kWSHWTg?t=12m20s

          // Use async to load bundle in header

          // Pull elements into scope using h1(title="Foo" {{as headline}})

      article#queries
        h2 Queries
        p
          | Queries are a specific type of collection that filters its contents according to a
          | given database query object. Once created, a query remains active, meaning that
          | matching objects that get added to the database will
          | show up after the fact and trigger the appropriate events. A Query will also update
          | when one of the properties filtered over changes for one of the objects in the collection.
        p
          | Queries can be narrowed down further, by calling the chainable filter method:
        pre(data-filename="app.js")
          code(class="javascript")
            | var finishedTodos = declaire.Query(Todo.all, {done: true});
            | var aboutSports = finishedTodos.filter({title: {$contains: 'sport'}});
            | // Use like a regular collection
            | aboutSports.each(function(todo) {
            |   todo.remove();
            | });
        p We can use a Query in a computed property together with an input binding for creating a live search feature:
        pre(data-filename="app.js")
          code(class="javascript")
            | declaire.ViewModel('SearchUsersView', {
            |   people: declaire.Query(Person.all),
            |   query: '',
            |   results: function() {
            |     // Filter works flawlessly on Person.name, btw,
            |     // which is itself a computed property
            |     return this.get('people').filter({name: {$contains: this.get('query')}});
            |   }
            | });
        pre(data-filename="views/searchUsers.tmpl")
          code(class="handlebars")
            | {{view SearchUsersView}}
            |   input(type="text" placeholder="Search for people" value="{{query}}")
            |   ul
            |     {{for results}}
            |       li {name}
        p
          | Here, the query property of the view model gets driven by its binding to the text input.
          | When the user inserts a character, query gets updated, fires a change event which causes
          | results to fire one as well, which causes the template engine to update the list of
          | search results.
        p Look ma! No ajax! No event handlers!

        section
          h3 Local Queries
          p
            | When a query is evaluated, it is performed against the local model cache first, returning
            | results almost immediately. When the user is online, a live query to the database is
            | then performed in the background, to fetch additional matching objects from the server.
            br
            | When these arrive, change events, as well as fetch event, will be emited by
            | the query, causing bound views und dependent properties to update.

      article#main-model
        h2 The Main Model
        p
          | The main model sits at the very bottom of every scope and gets created and updated
          | by the framework. It is not meant to be written to directly.
        p
          | It contains several properties of interest to
          a(href="#routing") routing
          | ,
          a(href="#offline") offline handling
          | ,
          a(href="#session") session
          | ,
          a(href="#components") components 
          | and potentially any application.
          br
          | Property names start with an underscore to prevent name collisions with your own properties.
        section
          h4 _page
          p
            | Contains another complete model object that acts as a mirror for the current url.
            | Read its <b>route</b>, <b>params</b> and <b>hash</b> properties to route your pages, or set them to navigate
            | from code.
          //- These get created dynamically and do not belong in the main model:
          //- h4 _params
          //- p
          //-   | Contains the parameters given to the import statement or view. Useful to delegate these to
          //-   | another view model.
          //- h4 _content
          //- p Contains markup nested below an import statement. Useful to customize reusable components.
          h4 _online
          p
            | Represents the current state of connectivity. Useful to show to the user when changes do
            | not currently reach the server.
          h4 _authenticated
          p Tells if the user is logged in.
          h4 _version
          p 
            | Changes as soon as a new version of the application is available and has been loaded
            | into the offline cache. This is a good point in time to inform the user that reloading the page
            | will bring new goodness.
          h4 _cookie
          p 
            | Contains another complete model object that acts as a mirror for the real browser session.
            | This allows you to use the cookie everywhere you can use a model.
        
        section
          h3 Accessing the Main Model Singleton Instance
          p As a part of any scope, its properties are available in any template.
          pre(data-filename="views/layout.tmpl")
            code(class="handlebars")
              | {{if !_online}}
              |   dialog Waiting for connection ...
          p The main model can also be accessed from javascript as a field on the main module.
          pre(data-filename="app.js")
            code(class="javascript")
              | declaire.mainModel.on('change:_version', function(v) {
              |   if(confirm('Reload to install new version?')) {
              |     window.location = window.location;
              |   }
              | });

      article#routing
        h2 Routing
        p
          | Declaire apps contain an implicit router, that lives as another model object inside the <b>_page</b>
          | property of the main model. This way, routing information is not only available to javascript,
          | but - because the main model lies at the top of every scope - to templates as well.
        p
          | Because it's a regular model object, it will emit change events when its
          | properties are written to, which are in turn caught by the template engine.
        pre(data-filename="views/layout.tmpl")
          code(class="handlebars")
            | body
            |   header
            |     h1 My Page
            |     nav>ul
            |       li>a(href="/") Home
            |       li>a(href="/pages/todos") Todos
            |   main
            |     {{if _page.route == '/'}}
            |       {{import IndexView}}
            |     {{if _page.route == '/pages/todos'}}
            |       {{import TodosView(_page.params)}}
        p If you want to access the router more directly, listen to its events using Javascript:
        pre(data-filename="app.js")
          code(class="javascript")
            | declaire.mainModel.get('_page').on('change:route', function(route) {
            |   console.log("The url changed to " + route);
            | });

      article#client-only
        h2 Running Client/Server-only Code
        p
          | By default, all your code is executed on both server and client, leading to consistent results.
          | Sometimes though, this will not do the trick and you might want to execute code only on the one side
          | or the other.
        p
          | Declaire accepts several hooks in its start method, that get executed at specific points
          | in time. Some on the server, some on the client:
        pre(data-filename="app.js")
          code(class="javascript")
            | console.log("Executed once on both client and server");
            |
            | declaire.start({
            |   beforeConnect: function(express, mongoDB) {
            |     console.log("Executed only on the server");
            |   },
            |
            |   onLoad: function() {
            |     console.log("Executed only on the client");
            |   }
            | });
        p
          | Declaire also provides helper methods to exclude arbitrary code segments, that can
          | be used both with a callback, or as a regular function:
        pre(data-filename="app.js")
          code(class="javascript")
            | // Continuation passing style
            | declaire.onServer(function() { });
            |
            | // Good ol' boolean function
            | if(declaire.onClient()) { }
        p
          | You can also require additional npm modules on one side only.
          | Modules which are only required on the server will not be included in the javascript bundle.
        pre(data-filename="app.js")
          code(class="javascript")
            | if(declaire.onServer()) require('newrelic');

      article#offline
        h2 Offline Support
        p
          | After the initial page load, Declaire apps can be reloaded - even across browser
          | restarts - when the device has no connection to the internet, by the virtue of a
          | framework generated offline manifest that is injected into your pages.
          br
          | Even when you are online, this will give your applications a serious boost on
          | subsequent loads. 
        p
          | Declaire also keeps a cache of checked out data models and can
          | silently retrieve any objects that had been loaded already from local storage,
          | without modifications to your code.
        p
          | Modifications to existing objects or newly created ones will be saved
          | locally until the server can be reached for synchronization again.
        p
          | All of this happens completely transparently to you. When your app needs to know
          | more about its internal state though, the 
          a(href="#main-model") main model 
          | contains several fields of interest.

      article#stylesheets
        h2 Stylesheets
        p
          | Declaire supports
          a(href="http://learnboost.github.io/stylus/") Stylus 
          | with 
          a(href="http://tj.github.io/nib/") Nib 
          | for writing your stylesheets.
          | These are great libraries and the indented syntax matches Declaire nicely.
          | Among lots of other functionality, they provide you with:
        pre(data-filename="stylesheets/main.styl")
          code(class="less")
            | // Server side imports
            | @require 'nib'
            |
            | // Cross-browser reset
            | global-reset()
            |
            | // Variables
            | $mainColor = #0aaaad
            |
            | // Apply vendor-prefixes automatically for unstandardized CSS
            | body
            |   background: linear-gradient(top, white, black)
            |
            | // Nested definitions
            | article
            |   margin: 3rem 0
            |   h2
            |     font-weight: bold
            |
            | // Color calculations, etc
            | a
            |   color: $mainColor
            |   &:hover
            |     color: $mainColor * 0.9
        p
          | Simply put your stylus files into the stylesheets folder of your application
          | and they will be served under the identical path, just with the .css extension.
        pre(data-filename="views/layout.tmpl")
          code(class="handlebars")
            | head
            |   link(href="/stylesheets/main.css" rel="stylesheet")

      article#deployment
        h2 Deployment
        p
          | Declaire works as a standard 
          a(href="http://npmjs.com") NPM 
          | library and doesn't use any special protocols beside HTTP. You should therefore
          | be able to deploy your application anywhere where node applications run.
        p
          | Be sure to set the environment variable NODE_ENV to 'production' on production
          | systems, to disable development guides like automatic reparsing of templates.
          br
          | This will also minify your assets and apply some other optimizations.
        section#mongodb
          h3 MongoDB
          p
            | Declaire will take connection information from the environment variables MONGOHQ_URL
            | and MONGOLAB_URI, unless you override this with the call to declaire.start().
            br
            | Because these variables are set by PaaS services like 
            a(href="http://heroku.com" target="_blank") Heroku
            | , this allows Declaire apps to connect to these popular services automagically.
          pre(data-filename="app.js")
            code(class="javascript")
              | declaire.start({
              |   mongoUrl: 'mongodb://my-host:27017/my-app'
              | });
        section#heroku
          h3 Heroku
          p
            | Follow these simple steps to wrap your app in a
            a(href="http://git-scm.com" target="_blank") Git 
            | repository and deploy it to
            a(href="http://heroku.com" target="_blank") Heroku
            | :
          pre(data-filename="Shell")
            code(class="javascript")
              | // Go to your app folder
              | $ cd my-app
              | // Initialize a git repository here
              | $ git init
              | // Make sure Git doesn't check in generated files
              | $ echo $'node_modules\npublic' > .gitignore
              | // Add everything else to the repo and commit
              | $ git add .
              | $ git commit -m "Initial commit"
              | // Create and configure an application on Heroku
              | $ heroku create my-app
              | $ heroku config:set NODE_ENV=production
              | // Add a database
              | $ heroku addons:add mongolab
              | // Deploy
              | $ git push heroku master
              | // Enjoy!
              | $ heroku open

  footer#footer
    ul.blocks
      li
        h4 Declaire
        ul.items
          li
            a(href="/") Home
          li
            a(href="https://www.npmjs.com/package/declaire") NPM
      li
        h4 Help
        ul.items
          li
            a(href="#install") Get started
          li
            a(href="/pages/examples") Examples
          li
            a(href="/pages/docs") Documentation
      li
        h4 About
        ul.items
          li
            a(href="/pages/license") License
          li
            a(href="/pages/imprint") Imprint
          li
            a(href="/pages/blog") Blog
      li
        h4 Connect
        ul.items
          li
            a(href="https://github.com/syntheticore/declaire")
              i.fa.fa-github
              | Github
          //- li
          //-   a(href="#")
          //-     i.fa.fa-facebook-square
          //-     | Facebook
          //- li
          //-   a(href="#")
          //-     i.fa.fa-twitter
          //-     | Twitter
    .bottom
      i.fa.fa-barcode
      span
        | Declaire was built with ❤ by
        a(href="https://github.com/syntheticore") Björn Breitgoff 
        | in Aachen, Germany

  script(src="/bundle.js" async)

  script
    | (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    | (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    | m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    | })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    | ga('create', 'UA-60705295-1', 'auto');
    | ga('send', 'pageview');
