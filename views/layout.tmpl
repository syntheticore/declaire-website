head
  meta(charset="UTF-8")
  meta(name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0")
  meta(content='text/html; charset=utf-8' http-equiv='Content-Type')
  meta(content='IE=edge, chrome=1' http-equiv='X-UA-Compatible')

  title Declaire.js

  link(rel="stylesheet" href="/stylesheets/main.css")
  link(href="/js/bower/fontawesome/css/font-awesome.min.css" rel="stylesheet")
  link(href="/js/bower/highlightjs/styles/github.css" rel="stylesheet")
  link(rel="shortcut icon" href="/favicon.png")

body
  header#header
    .logo
      i.fa.fa-barcode
      span Declaire
    nav
      ul
        li
          a(href="#features") Features
        li
          a(href="#install") Get Started
        li
          a(href="/pages/docs") Documentation
        //- li
        //-   a(href="https://github.com/syntheticore/declaire") Github

  main
    header
      h1 Declaire.js
      h2 A minimal, yet complete Web Application Framework
      a.cta(href="#install") Get Started
      
    article#features
      ul.features
        li
          h3 Minimal, yet a complete Package
          p
            | Declaire.js allows you to write a single web application that runs on both
            | client and server.
          p
            | Pages are first generated in a streaming fashion on the server
            | - for short time to first byte and easy SEO - and get rehydrated on the client
            | afterwards, using the same codebase.
          p
            | Declaire brings its own templating language, with a compact, Jade-inspired syntax
            | and a robust set of logic blocks for structuring your markup.
          p
            | RESTfull resources get served for your models automatically, without the need to write
            | additional code. Just define a data model, create instances and you're good to go.
          p
            | Stylesheets written in Stylus/nib are compiled and served automatically for you.
        
        li
          h3 Declarative
          p
            | The template is the highest authority in a Declaire application and manages most
            | application state for you.
          p
            | ViewModels get instantiated and deleted by the template engine
            | as neccessary when data changes, freeing you from having to manage memory and event
            | handlers yourself.
          p
            | Writing application code in this declarative way minimizes overhead and prevents many
            | common programming mistakes.
        
        li
          h3 Realtime Sync
          p
            | Model state is kept current with the remote database at all times automatically.
          p
            | Declaire does this in a scalable fashion, without the need for an additional PubSub
            | server like Redis. A single MongoDB connection is sufficient for all data storage
            | and synchronization needs.
        
        li
          h3 Auto Bindings
          p
            | Watch the DOM magically update, as your model data changes. No matter if those changes
            | resulted from your own actions or from updates to the server.
        
        li
          h3 Computed Properties
          p
            | Computed properties are like regular model methods, except that they also emit change
            | events when one of the properties they depend on changes. This allow you to hook up
            | complex logic to templates in a completely declarative way.
          p
            | Dependency tracking happens automatically, without the need to declare these
            | relationships ahead of time.
        
        li
          h3 Offline First
          p
            | All Declaire applications work offline by default.
            | Data changes are kept in local browser storage when offline and get synced back to
            | the server later, when connectivity is available again.

        li
          h3 Streaming Server
          p
            | When templates get first rendered on the server, Declaire utilises Node.js' streaming technology
            | to transmit the first few bytes as soon as possible. Browsers can already display content
            | and start downloading additional resources, while the database is still returning data.
        
        li
          h3 Based on trusted Technology
          p
            | Declaire runs on Node.js and uses Express internally to serve requests.
            | Data is stored in a MongoDB instance, and code is packaged using Browserify.
          p
            | The express app, as well as the connected database instance are exposed to interested
            | applications just before listening for requests.
            | This allows you to hook up legacy code or load additional express middleware and make
            | changes to the database before serving requests.

        li
          //- h3 Decidedly Web
          h3 ❤ ing the Web
          p
            | In the transition from server generated pages to single page applications, some values
            | of the web have been lost in translation.
          //- p
          //-   | Pages often only contain a small fragment of
          //-   | container html and generate everything else using javascript. Some frameworks these days
          //-   | even go as far as bypassing the http protocol completely and transmit everything over websockets.
          //- p
          //-   | This is not only problematic for search engines and comparatively slow when it comes to
          //-   | time to first impression, but also undermines the movement to semantic html somewhat,
          //-   | by relying on a "semantic DOM" that only high-powered, javascript-savy browser engines
          //-   | can still consume, instead of, say, a simple shell script.
          p
            | Declaire therefore delivers:
            br
            | Full HTML instead of JS-only.
            br
            | Data over standard REST/json.
            br
            | Push updates using Server-Sent-Events over standard HTTP instead of websockets.

        // Implicit router and offline handling through scope
        // Authentication and permission system

    article#install
      h2 Install Declaire
      p
        | Install Declaire into any node application using npm.
      pre(data-filename="Shell")
        code(class="bash")
          | $ cd my-app
          | $ npm install declaire --save

    article#get-started
      h2 Get Started
      p
        | To build a simple todos application, create an application file, load declaire, define your models and
        | supply the start method with the address of your development database.
      pre(data-filename="app.js")
        code(class="javascript")
          | var declaire = require('declaire');
          |
          | var Todo = declaire.Model('todos', {
          |   title: 'Untitled Todo',
          |   done: false
          | });
          |
          | declaire.ViewModel('TodosView', {
          |   todos: declaire.Collection(Todo),
          | 
          |   newTodo: function(input) {
          |     this.get('todos').create({title: input.val()});
          |     input.val('');
          |   }
          | });
          |
          | declaire.start({
          |   mongoDevUrl: 'mongodb://127.0.0.1:27017/my-app'
          | });
      p
        | Create your main layout template in the views folder.
        | Declaire will wrap it with an html tag automatically if you omit it.
      pre(data-filename="views/layout.tmpl")
        code(class="handlebars")
          | head
          |   title Todos
          |   link(href="/stylesheets/main.css" rel="stylesheet")
          | body
          |   {{view TodosView}}
          |     header
          |       h1 Todos
          |     main
          |       input(type="text" placeholder="What's next?" {{action change newTodo}})
          |       ul.todos
          |         {{for todos}}
          |           li
          |             input(type="checkbox" checked="{{done}}")
          |             h2 {title}
          |     footer {todos.length} items left to do
      p
        | Finally, run your application using
      pre(data-filename="Shell")
        code(class="bash")
          | $ node app.js

    article#templates
      h2 Basic Templating
      p
        | Declaire's templating language borrows heavily from Jade, but differs in notable ways.
        br
        | Hierachy is denoted through indentation, while most other syntax choices try to adhere
        | as much as possible to the CSS syntax. A fully defined tag might look like this:
      pre(data-filename="views/layout.tmpl")
        code(class="handlebars")
          | .pane
          |   input#my-id.foo.bar(type="text" checked)
      p
        | We used the '#' character to give the input an id, applied several classes using '.' and
        | set some attributes using the regular html notation.
        br
        | When an id or class is used, divs may have the tagname omited, as divs are the default.

      section
        h3 Interpolation
        p
          | Any value available in the surrounding scope can be interpolated at any practical point
          | in a template using a pair of curlies. This also works for attributes.
        pre(data-filename="views/layout.tmpl")
          code(class="handlebars")
            | .todo
            |   h2 {title}
            |   input(type="checkbox" checked="{done}")
        p
          | By default, text gets escaped before being inserted into the page, to prevent injection attacks.
          | If you precede the curlies with an exclamation mark though, you can insert unescaped text.
          | Use this at your own risk!
        pre(data-filename="views/layout.tmpl")
          code(class="handlebars")
            | h2 !{title}
      
      section
        h3 Bindings
        p
          | Using double curlies in an attribute will create a two-way binding, meaning that the
          | input will drive the connected model property when the user makes changes.
        pre(data-filename="views/layout.tmpl")
          code(class="handlebars")
            | input(type="checkbox" checked="{{done}}")
      
      section
        h3 Free flowing text
        p
          | When your text doesn't fit on a single line anymore, you can end a tag definition with a dot
          | and indent the following lines below. Text may also contain regular html tags.
        pre(data-filename="views/layout.tmpl")
          code(class="handlebars")
            | p.
            |   Lorem ipsum dolor sit amet
            |   Lorem ipsum &lt;b&gt;dolor&lt;/b&gt; sit amet
        p
          | Alternatively, you may insert text anywhere you would insert a regular tag, by preceding it
          | with the '|' character. This allows you to still insert intermediate tags using the regular
          | syntax. 
        pre(data-filename="views/layout.tmpl")
          code(class="handlebars")
            | p
            |   | Lorem ipsum
            |   a(href="#") dolor 
            |   | sit amet

      section
        h3 Control Flow
        p
          | Several statements are available in templates to control the generated markup in response
          | to changes to its underlying data, accessible through their respective keywords in double curlies.
        section
          h4
            | If
          p
            | The if statement is different from Javascript and does not execute arbitrary code.
            | Only paths to model or view model properties within the scope, as well as basic literals
            | are allowed, together with a fixed set of comparison operators. Inversion works too.
          pre(data-filename="views/layout.tmpl")
            code(class="handlebars")
              | {{if person.name == 'Peter'}}
              |   strong Congratulations Peter!
              |   {{if person.age < 18}}
              |     .advice Shut your eyes!
              |
              | {{if !_online}}
              |   dialog Waiting for connection ...
        section
          h4
            | For
          p
            | Use the for-statement to iterate through collections and arrays and produce output for
            | every item.
          pre(data-filename="views/layout.tmpl")
            code(class="handlebars")
              | ul
              |   {{for todo in todos}}
              |     li {todo.title}
          p
            | You can also use the short form, which will insert each item directly into the scope,
            | making its properties visible from that point downwards in the template.
            br
            | Note that its properties may shadow properties or variables of the same name, higher in
            | the scope. These can then no longer be reached.
          pre(data-filename="views/layout.tmpl")
            code(class="handlebars")
              | ul
              |   {{for todos}}
              |     li {title}
        section
          h4
            | View
          p
            | Views instantiate view models when they are encoutered in a template and and put these
            | into the scope. Their properties are subsequently available in the scope.
          p
            | Once a view is no longer needed, perhaps because its item was removed from a collection,
            | or because a parent element got updated, Declaire will remove the associated model object
            | automatically.
          pre(data-filename="views/layout.tmpl")
            code(class="handlebars")
              | {{if showSomeView}}
              |   {{view MyViewModel}}
              |     h1 {title}

      section
        h3 Scope
        p

    article#models
      h2 Data Models
      p
        | Data models structure your application data and code, shield you from the database, provide offline
        | capabilities and report updates to their data to interrested listeners using events.
      p
        | A model definition consists of a collection name, defaults for your attributes and methods to operate on that data.
        br
        | Supply the collection name as the first parameter. In this example, JSON data for your todos
        | will be available under the url /api/todos.
      p
        | Note that model properties get accessed using getter and setter functions and never directly.
      pre(data-filename="app.js")
        code(class="javascript")
          | var Todo = declaire.Model('todos', {
          |   title: 'Untitled Todo',
          |   done: false,
          |
          |   check: function() {
          |     this.set('done', true);
          |   }
          | });
      p
        | Individual models can now be created from that definition using the create method.
        | You can also pass a hash of values to the constructor to set some properties directly on creation.
        br
        | Once created, the object is visible to your application and fully functional, but is not
        | persisted to the server yet. To make it visible to other users of the app as well,
        | we need to save it to the database using the appropriately named method.
      pre(data-filename="app.js")
        code(class="javascript")
          | var todo = Todo.create({title: 'Foo'});
          | todo.check();
          | todo.save();
      p As a convenience, setting properties and saving immediately can be done in a single method call.
      pre(data-filename="app.js")
        code(class="javascript")
          | todo.save({done: true});
      
      section
        h3 Events
        p
          | In many cases, the event system is invisible to you and is used by the template engine
          | automatically to update the DOM when data in your models changes.
          | You can also access it yourself however, using a handful of methods:
        pre(data-filename="app.js")
          code(class="javascript")
            | todo.on('change', function() {
            |   console.log("Some property changed");
            | });
            |
            | todo.on('change:title', function() {
            |   console.log("The title changed to " + todo.get('title'));
            | });
            |
            | todo.once('change', function() {
            |   console.log("This will get called only on the next change");
            | });
        p The on method returns the handler itself, so that it can be unregistered again later:
        pre(data-filename="app.js")
          code(class="javascript")
            | var handler = todo.on('change', function() {});
            | todo.off(handler);
      
      section
        h3 Computed Properties
        p
          | Regular model methods implicitly become Computed properties simply by accessing them
          | from a template or through the get() method.
          br
          | They will then trigger change events, just like normal properties, when one of their
          | dependencies changes. These dependencies are tracked automatically upon the first
          | call to get() and will subsequently get updated on every access.
        pre(data-filename="app.js")
          code(class="javascript")
            | var Person = declaire.Model('people', {
            |   name: '',
            |   lastName: '',
            |
            |   fullName: function() {
            |     return this.get('name') + ' ' + this.get('lastName');
            |   }
            | });
        pre(data-filename="views/ContactView.tmpl")
          code(class="handlebars")
            | h1 {fullName}
      
      //- section
      //-   h3 Loading Models
      //-   p
      //-     | 

    article#view-models
      h2 View Models
      p
        | View models inherit from regular models but fulfill a different purpose.
        br
        | They are the building blocks of your UI logic, cannot be saved and export a name by which they can
        | be accessed from within templates.
      p
        | Normally, a view model will want to fetch data on instantiation to make it available to templates.
        | Note that, as opposed to normal models, you will generally not want to instantiate and delete these
        | yourself, as this job is done by the template engine automatically.
      section
        h3 Lifecycle event hooks
        p
          | View models have a few additional methods to hook into their template driven lives.
          | These are basically sugar for listening to the 'create' and 'remove' events of the
          | instantiated models, which would otherwise be hard to get by, when your model is first instantiated
          | by the template engine.
        pre(data-filename="app.js")
          code(class="javascript")
            | var i = 1;
            | declaire.ViewModel('MyView', {
            |   title: '',
            |
            |   onCreate: function() {
            |     this.set('title', 'View ' + i++);
            |   }
            |
            |   onRemove: function() {
            |     console.log(this.get('title') + " is leaving the ship...");
            |   }
            | });
        h4 onCreate
        p
          | View this as a constructor.
        h4 onRemove
        p
          | You should unbind any external handlers that you have bound during the lifetime of the object here
          | and destroy everything else you may have set up.

    //- article#main-model
    //-   h2 The Main Model
    //-   p

    article#organizing-templates
      h2 Organizing Templates and Components
      p
        | Declair uses a simple way to combine templates that also serves as a basis to build
        | reusable components:
        | Use the import instruction to import another template in the surrounding template.
      p
        | We can use this to refactor our todos app from above and
        | make the TodosView a reusable component that we can insert at multiple locations.
        br
        | Parameters passed to the imported template are delegated to the topmost node inside.
      pre(data-filename="views/TodosView.tmpl")
        code(class="handlebars")
          | {{view TodosView}}
          |   header
          |     h1 Todos
          |   main
          |     input(type="text" placeholder="What's next?" {{action change newTodo}})
          |     ul.todos
          |       {{for todos}}
          |         li
          |           input(type="checkbox" checked="{{done}}")
          |           h2 {title}
          |   footer {todos.length} items left to do
          //- |   .embed
          //- |     {_content}
      pre(data-filename="views/layout.tmpl")
        code(class="handlebars")
          | head
          |   title Todos
          |   link(href="/stylesheets/main.css" rel="stylesheet")
          | body
          |   {{import TodosView}}
          |   span And another one
          |   {{import TodosView}}
          //- |     h1 This is inserted content

    article#router
      h2 Routing URLs
      p
        | Declaire apps contain an implicit router, that sets several properties of the main
        | model automatically. This way, routing information is not only available to javascript,
        | but - because the main model lies at the base of every scope - to templates as well.
      p
        | Because the main model is a regular model object, it will emit change events when its
        | properties are written to, which are in turn caught by the template engine.
      pre(data-filename="views/layout.tmpl")
        code(class="handlebars")
          | body
          |   header
          |     h1 My Page
          |     nav>ul
          |       li>a(href="/") Home
          |       li>a(href="/pages/todos") Todos
          |   main
          |     {{if _page == '/'}}
          |       {{import IndexView}}
          |     {{if _page == '/pages/todos'}}
          |       {{import TodosView(_params)}}

    article#client-only
      h2 Running client- (or server-) only code
      p
        | By default, all your code is executed on both server and client, leading to consistent results.
        | Sometimes though, this will not do the trick and you might want to execute code only on the one side
        | or the other. Declaire offers several ways to do this:
      p
        | Declaire accepts several hooks in its start method, that get executed at specific points
        | in time. Some on the server, some on the client. Consult the
        a(href="/pages/docs") docs 
        | for more detailed information!
      pre(data-filename="app.js")
        code(class="javascript")
          | console.log("Executed once on both client and server");
          |
          | declaire.start({
          |   beforeConnect: function(express, mongoDB) {
          |     console.log("Executed only on the server");
          |   },
          |
          |   onLoad: function(mainModel) {
          |     console.log("Executed only on the client");
          |   }
          | });
      p
        | Declaire also provides helper methods to exclude arbitrary code segments, that can
        | be used both with a callback, or as a regular function:
      pre(data-filename="app.js")
        code(class="javascript")
          | // Continuation passing style
          | declaire.onServer(function() { });
          |
          | // Good ol' boolean function
          | if(declaire.onClient()) { }

    article#stylesheets
      h2 Stylesheets
      p
        | You can use anything you want of course, but by default, Declaire supports
        a(href="http://learnboost.github.io/stylus/") Stylus 
        | with 
        a(href="http://tj.github.io/nib/") Nib 
        | for writing your stylesheets.
        | These are great libraries and the indented syntax matches Declaire nicely.
        | Among lots of other functionality, they provide you with:
      pre(data-filename="stylesheets/main.styl")
        code(class="less")
          | // Server side imports
          | @require 'nib'
          |
          | // Include cross-browser reset
          | global-reset()
          |
          | // Assign to variables
          | $mainColor = #0aaaad
          |
          | // Apply vendor-prefixes automatically for unstandardized CSS
          | body
          |   background: linear-gradient(top, white, black)
          |
          | // Nest definitions
          | article
          |   margin: 3rem 0
          |   h2
          |     font-weight: bold
          |
          | // Make color calculations, etc
          | a
          |   color: $mainColor * 0.9
          |   &:hover
          |     color: $mainColor
      p
        | Simply put your stylus files into the stylesheets folder of your application
        | and they will be served under the same path, just with the .css extension.
      pre(data-filename="views/layout.tmpl")
        code(class="handlebars")
          | head
          |   link(href="/stylesheets/main.css" rel="stylesheet")

  footer#footer
    ul.blocks
      li
        h4 Declaire
        ul.items
          li
            a(href="/") Home
          li
            a(href="/pages/blog") Blog
      li
        h4 Help
        ul.items
          li
            a(href="#get-started") Get started
          li
            a(href="/pages/examples") Examples
          li
            a(href="/pages/docs") Documentation
      li
        h4 About
        ul.items
          li
            a(href="https://github.com/syntheticore") Contact
          li
            a(href="/pages/imprint") Imprint
      li
        h4 Connect
        ul.items
          li
            a(href="https://github.com/syntheticore/declaire")
              i.fa.fa-github
              | Github
          //- li
          //-   a(href="#")
          //-     i.fa.fa-facebook-square
          //-     | Facebook
          //- li
          //-   a(href="#")
          //-     i.fa.fa-twitter
          //-     | Twitter
    .bottom
      i.fa.fa-barcode
      span
        | Declaire was built with ❤ by
        a(href="https://github.com/syntheticore") Björn Breitgoff 
        | in Aachen, Germany

  script(src="/js/bower/jquery/dist/jquery.min.js")
  script(src="/js/bower/underscore/underscore-min.js")
  script(src="/js/bower/backbone/backbone.js")
  script(src="/js/bower/highlightjs/highlight.pack.js")
  script
    | hljs.initHighlightingOnLoad();
  //- script(src="/bundle.js")
